## 分析思想
- 采用正规匹配(非正则匹配)的方式进行词法解析, 这种方式就是逐一匹配, 直到不满足自身匹配为止
- 曾经有的编译器使用状态机的方式进行词法分析(现在基本不这样用), 这种方式会导致异常的混乱, 需要非常多的标记变量, 而且不易拓展; 如果语句比较复杂, 状态的维护非常困难

## 分析流程
- 每次读取一个字符, 定义该字符的处理方式, 在处理方式中循环读取, 直到不属于该处理方式为止
	- 假设读取到的字符是一个数值, 那么进入数值处理方法, 在该方法中循环读取, 直到出现不是数值的字符, 就停止循环
	- 假设读取到的字符是 _ / [a-z] / [A-Z], 那么进入到处理 id 的方法中, 在该方法中, 如果检测到的不是 _ / [a-z] / [A-Z] / [0-9], 那么就停止循环
- 跳出循环后, 解析的索引应该指向不满足的那个字符位置, 所以在判断下一个字符时, 使用 lookup 的方式来, 而不是 take
	- lookup: 就是查看下一个字符, 但是不移动index位置
	- take: 获取下一个字符, 并且移动index的位置

## 注意点
- 从文本中读取到的字符没有转义而言, 所以需要处理
	- 比如: \r\n, 读取后是4个字节('\' 'n' '\' 'r'), 而不是2个字节('\r' '\n')
- 考虑到用户编写语言的感受, lions-language 不单纯的使用分号作为语句的终结, 如果用户想用换行来结束一条语句, 也是需要支持的, 所以在 词法分析阶段, 不能忽略换行符
- 为了在字符串中使用变量, lions-language 中引入 fmt<左终结符><右终结符>"" 形式的字符串定义形式
	- 为了不在运行时对字符串解析, 此功能内置于解析器中, 所以在词法分析阶段, 需要将此语句解析为一个特殊的 string token, 并根据左右终结符, 将字符串中的变量信息提取为token
		- 如: fmt<${><}>"hello ${name}", 解析后的token应该为:
			```
			Token_String "hello "
			Token_Opt_Plus
			Token_Id "name"
			```

