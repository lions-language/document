## 匿名函数
### 语法设计
- func([params]) {}

## 结构体方法
### 语法设计
- func [Type] name([params])
- func [name: Type] name([params])

### 设计说明
- Type: 表示的是要实现的结构体类型
- 为什么用 [] 将结构体类型括起来?
	- 主要是为了提高解析效率, 如果使用 小括号, 因为和匿名函数有语法冲突, 如果要判断是匿名函数还是结构体方法, 将需要进行回溯, 这将导致效率降低
- [Type]: 表示的是结构体相关的方法
- [name: Type]: 表示的是结构体成员方法, 通过对象调用
- 使用 : 分割的原因
	- 使用 : 分割, 可以区分是 [name: Type] 格式 还是 [Type] 格式

## 函数声明
### 作用
- 为了快速查找函数是否定义
	- 如果定义了, 找到函数实现的位置

### 命名规则
- [所属类型] 函数名 [参数列表[参数类型]] [返回值类型]

### 函数声明序列化
- 将函数的声明转换为字符串
    - 方式一
        - 类型:函数名(参数类型列表)->(返回值列表)
            - 如: uint32 的 + 方法
                - uint32:+(uint32)->(uint32)
   - 方式二
        - 类型对象 -> 类型属性|类型:函数名(参数类型列表)
            - 如: uint32 的 + 方法
                - 存在一个 uint32 的类型对象, 该对象中存储了: uint32:+(uint32) 字符串, 或者 &uint32:+(uint32), 再或者 *uint32:+(uint32)
		- 为什么要加属性, 因为不同的属性是视为不同的方法的
- 比较
    - 为什么方法的序列化没有添加返回值
        - 为什么要序列化, 因为在函数调用的时候, 需要按照序列化的结果从对象的内存中查找, 但是在函数调用时, 无法快速得知函数的返回值, 如果想获取函数的返回类型, 将通过上下文推断
            - 如, 有一个方法: get_number_one(), 有运算: 1 + get_number_one(), 遇到 get_number_one() 时, 编译器将去查找方法, 但是此时无法知道 get_number_one() 的返回类型, 如果想获取类型, 那么需要从 1 + 入手, 也就是说 get_number_one() 的返回类型应该和 1 一致, 但是事实不一定是这样, 1 可能是 uint8 / uint16 / uint32 / ..., 那么就需要挨个去查找, 这就需要花费大量的时间
        - 另外一点就是, 在这种不确定情况下, 将可能导致程序的逻辑错误, 为了让编码人员快速发现问题, 应该尽可能在编译期就提示错误
    - 方式二优于方式一
        - 方法的查找放在了每一个对象中, 每一个映射中的数据量小了, 自然速度就快了

### 存储结构
- 为了快速索引, 使用树状结构存储, 类似前缀树
