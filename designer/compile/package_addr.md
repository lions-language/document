## 多个 package, 如何正确定位代码段地址
- 每一个package, 编译后应该记录自身 代码段 的总大小
- 每一个package中的定义, 编译生成的字节码中的地址应该都是相对地址(从0开始), 但是被调用的时候需要动态读取初始值, 也就是说每次获取地址时, 需要从package的映射中(在链接过程中会给出package映射)找到初始值, 然后加上相对地址, 得到的就是真实的地址
- 字节码中写入的是 初始地址+相对地址
	- 初始地址: 在编译的时候, 为每一个 package 分配一个 index
	- 链接的时候, 将 编译期得到的 package index, 映射为实际的初始地址
	- 运行时, 读取字节码中的 package index, 然后根据映射, 得到实际的初始地址, 然后与字节码中的相对地址相加, 得到了真实的地址
- 比如
	- 有 pkg1(大小为 100), pkg2(大小为 200), crate(大小为 150)
		- 编译期(函数调用的时候, 查找 package):
			- pkg1 <-> 0
			- pkg2 <-> 1
			- crate <-> 2
		- 链接时:
			- 读取每一个package代码段的总大小, 将 0 映射为 100, 将 1 映射为 100+200=300, 将 2 映射为 100+200+150=450
			- 链接时, 如果存在嵌套引用, 将递归填充每一级的映射
		- 运行时:
			- 遇到了 0, 通过映射, 得到的是 100, 然后加上自己的相对地址, 得到的就是最后的真实地址

## 定义的链接
- 存在一个全局的 package index 分配器
	- (包名, 版本) <-> 全局索引值
