## 为函数调用做准备工作
- 在编译期, 将函数调用之前需要的参数放入到栈中
- 编译期, 分析出返回值应该存储的位置

## 编译期存储
- 为每一个实际存储(叶子节点)创建一个引用计数
- 如果参数是 Move, 将相应叶子节点的引用计数值设置为0
	- 检测返回值信息
		- 如果返回值是 Move, 取出 move 的索引, 对相应索引指向的叶子节点的引用计数+1
		- 如果返回值是 Create, 说明被移动的参数在函数结束后, 生命周期结束, 所以在函数结束后, 会因为引用计数为0, 而被释放; 同时, 需要在数据区分配一个地址 (并放入引用技术容器中)
- 如果参数是 Move, 所有权交由函数内部, 外部无权释放, 外部要做的就是在调用函数之前, 将实际的地址拿出来给函数, 如果要释放, 函数内部会将给定的地址释放掉
- 如果返回值是一个新创建的值, 那么所有权就交由调用方, 等到调用方相关作用域结束后, 被释放
- 如果返回值不是 Move, 需要检测拥有所有权的变量, 然后依次释放

## 作用域
- 进入作用域
	- 记录进入时的地址值 start_addr
- 出作用域
	- 存在返回值
		- 将返回值存储在 start_addr 中
		- 除了返回值的内存, 其他都需要释放
	- 不存在返回值
		- 将地址值设置为 start_addr
		- 释放作用域内的所有内存

## 函数定义
- 在进行函数调用的时候, 判断被调用的函数是否定义了
	- 未定义
		- 编译函数, 不写入到字节码中(改变写入走向)
			- 提供一个接口 DefineFunction, 并为每一个方法定义创建一个 DefineFunction 的实体对象, 并为函数定义做好映射 (FunctionKey <-> DefineFunction); FunctionKey 应该在整个编译单元中是唯一的
			```rust
			trait DefineFunction {
				fn new(index: u64) -> Self;
				fn write(&mut self, instruction: Instruction);
				fn fill_func_addr(&mut self, pos: &Position, addr: &AddressKey);
				fn push_undefine(&mut self, other: &Self, pos: Position);
				fn is_exist_will_filled(&mut self) -> bool;
				/*
				 * 返回在 Dispatch 中的索引
				 * */
				fn index(&self) -> u64;
				/*
				 * AddressKey 是函数定义后, 写入到 代码块 的地址信息
				 * 该方法中, 实现类 应该将缓存写入到 代码段中, 并返回写入后, 在代码段中的位置信息
				 * 	结束后需要做的几件事情
				 *  1. 需要填充 undefine 队列中的地址信息
				 *  	在调用每一次填充后, 根据 is_exist_will_filled() 判断是否存在待填充的函数定义, 如果不存在, 将 index() 的返回值添加到 待移除队列中, 然后将其返回, 提供给 Dispatch 进行管理
				 * */
				fn define_end(&mut self, storage_context: StorageContext) -> (AddressKey, Vec<u64>);
			}

			struct DefineFunctionDispatch {
			}
			```
			- 将 FunctionKey 与 DefineFunction 绑定 (之后称之为 FDMap)
		- 如果检测到函数未定义, 但是在 FDMap 中, 说明是递归调用, 需要先预留位置, 并将其写入到 FunctionKey 待填充的队列中, 等到函数定义完成, 对队列中的位置进行填充
	- 已定义
		- 从声明中获取地址, 然后直接将地址写入到字节码

## 函数调用流程
### 编译函数体时, 遇到函数调用
- 前提条件
	- 以模块为编译单元
	- 每一个模板编译的时候就要准备一个 define_dispatch
- 根据 package信息, module信息, function信息, 在函数声明中查找
	- 存在
		- 获取函数定义的地址, 并写入字节码
	- 不存在
		- 判断 define_dispatch 中是否存在
			- 存在
				- 获取存在的对象, 并将自身(正在编译的函数)写入到获取到对象中
					- 可能是自身调用自身, 没关系, 一样写入
				- 每个模块在自身编译完后, 都会将存储在自身队列中的待填充列表填充一下
			- 不存在
				- 是否调用的是其他模块
					- 是
						- 启动新的编译单元
					- 否 (说明截止到现在为止, 没有编译正在调用的函数: 调用在定义之前)
						- 将待填充信息添加到模块的(未定义 待填充列表中), 该列表在当前模块都编译完成后, 对列表进行填充
							- 根据习惯, 应该先编译当前文件的后文, 再编译同模块的其他文件

## 地址分配
- 编译期
	- 函数调用之前创建一个作用域, 并将函数需要的参数地址传递给函数
	- 函数调用结束时, 结束作用域
- 运行时
	- 检测到进入/离开作用域的指令后, 创建/释放一个作用域
	- 函数内部获取参数的时候, 需要从当前作用域的前一个作用域中查找数据地址
	
## 处理 strfmt
### 如何实现 str+other(str+uint ...)
- 语法分析阶段, 将 call_function 分为两个阶段
	- call_function_prepare 阶段: 此阶段, 编译期查找函数声明, 然后保存下来(ctx), 之后的参数表达式解析时, 根据参数的类型, 决定表达式的计算过程是否需要进行一些特殊操作
	- call_function_calc 阶段: 此阶段, 为函数调用分配地址, 然后生成指令
- 比如说, println 函数, 存在一个变长参数, 且类型是 str, 那么在进行表达式解析的时候, 如果遇到了 uint32 类型, 那么根据 ctx, is_auto_call_totype 是 true, 则: 需要调用 uint32 的 to_str 方法

## call self
### 思路
- 除了第一次调用, 以后的每一次调用都是相同的指令集合(每次进入函数后, 输入都是进入时的环境, 而这些环境都是一样的(地址相同))
- 除了第一次, 之后的每一次应该都用指令控制跳转到相同的部分, 而虚拟机应该保存每次调用前的位置, 以便结束调用后, 可以继续执行上一次之后的指令

